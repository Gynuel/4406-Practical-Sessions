---
title: 'Programming in R: Solutions for the exam part 1 (13/12/2024)'
output:
  pdf_document: default
  word_document: default
  html_document: default
subtitle: Your Name (10/01/25)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(dplyr)
```


\newpage



# Part 1 : the <tt>Hitters</tt> data

For the analysis of this part we use the data <tt>Hitters</tt> which is a part of the R package <tt>ISLR</tt>. This is the major league baseball data from the 1986 and 1987 seasons. More information can be found in https://rdrr.io/cran/ISLR/man/Hitters.html. The code below can be used to access the data

```{r}
library(ISLR)
data(Hitters)
names(Hitters)
```

## Question 1

In this question we focus on the player's division at the end of 1986 (the variable <tt>Division</tt>) and the number of runs in 1986 (the variable <tt>Runs</tt>). 

 1. How many observations are there in each category of the variable <tt>Division</tt>?
 
 2. Produce the table below.
 
 3. Test if the  number of runs (the variable <tt>Runs</tt>) is equal across the divisions. Conduct a Wilcoxon test for two independent samples.
 
 4. Produce Figure 1.1. Note that the points in red are the sample means.


### Solution Q1.1
```{r}
division_counts <- table(Hitters$Division)
print(division_counts)
```
### Solution Q1.2
```{r}
# Calculate median runs for each Division
median_runs_table <- Hitters %>%
  group_by(Division) %>%
  summarize(median_runs = median(Runs, na.rm = TRUE)) %>%
  as_tibble()

# Print the result
print(median_runs_table)
```
### Solution Q1.3
```{r}
wilcox_test <- wilcox.test(Runs ~ Division, data = Hitters, exact = FALSE, na.action = na.omit)
print(wilcox_test)
```
### Solution Q1.4
```{r}
# Load required libraries
library(ggplot2)
library(gridExtra)
library(grid)

# Load the dataset
data(Hitters)

# Remove missing values
Hitters_clean <- na.omit(Hitters)

# Calculate sample means for each Division
means <- aggregate(Runs ~ Division, data = Hitters_clean, mean)

# First plot: Boxplot with sample means
boxplot_plot <- ggplot(Hitters_clean, aes(x = Division, y = Runs)) +
  geom_boxplot(fill = "grey80", color = "black", outlier.shape = NA, alpha = 0.5) +  # Reduced opacity
  geom_point(data = means, aes(x = Division, y = Runs), 
             color = "red", size = 3) +
  labs(x = "Division", y = "Runs") +
  theme_minimal()

# Second plot: Violin plot with sample means
violin_plot <- ggplot(Hitters_clean, aes(x = Division, y = Runs)) +
  geom_violin(fill = "lightblue", color = "black", alpha = 0.5) +  # Reduced opacity
  geom_point(data = means, aes(x = Division, y = Runs), 
             color = "red", size = 3) +
  labs( x = "Division", y = "Runs") +
  theme_minimal()


# Combine the plots side by side using gridExtra
grid.arrange(boxplot_plot, violin_plot, ncol = 2)

# Add label to bottom left using grid.text
grid.text("Figure 1.1", x = 0.1, y = 0.02, gp = gpar(fontsize = 10, fontface = "plain"))

```



## Question 2

In this question we focus on the variable number of walks in 1986 (the variable <tt>Walks</tt>) in addition to the variables from Q1. 

1. Produce Figure 1.2, 1.3, and 1.4.
2. Produce the table below (correlation between Walks and run by division group)
3. Fit the following linear regression model:
4.  Define a R object <tt>fit.coef</tt> in which you store the parameter estimates of the coefficients and print the object.
5. Let $e_{i}$ the residual obtained for the regression model in Q2.3. Let $es_{i}$ the standardized residual given by:
  $$es_{i}=\frac{e_{i}}{MSE}$$
  Check if the standardized residuals follow a standard normal distribution using a qq normal probability plot shown in Figure 1.5.
  
  

### Solution Q2.1
```{r}
# Create a scatterplot between Walks and Runs, disaggregated by Division
scatterplot <- ggplot(Hitters, aes(x = Walks, y = Runs, color = Division)) +
  geom_point(size = 1, alpha = 0.8) +  # Add points with specified size
  scale_color_manual(values = c("E" = "red", "W" = "black")) +  # Color E points red, W points black
  labs(
    x = "Walks",
    y = "Runs",
    color = "Division"  # Label for the legend
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(t = 20, r = 20, b = 50, l = 20),  # Adjust bottom margin to create space for subtitle
    plot.subtitle = element_text(hjust = 0, vjust = 1, size = 10, face = "plain"),  # Left-align the subtitle
    plot.caption = element_text(hjust = 0, vjust = 0, size = 10, face = "plain")  # Add custom caption as bottom-left label
  )

# Add the label "Figure 1.2" using caption (treated as subtitle outside the plot area)
scatterplot <- scatterplot +
  labs(caption = "Figure 1.2")  # This moves the label to the bottom-left corner

# Show the plot
print(scatterplot)
```
```{r}
# Separate data for Division E and Division W
division_e <- subset(Hitters, Division == "E")
division_w <- subset(Hitters, Division == "W")

# Create the scatter plot for Division E (blue dots)
plot_e <- ggplot(division_e, aes(x = Walks, y = Runs)) +
  geom_point(color = "blue") +  # Blue dots
  labs(title = "Division E", x = "Walks", y = "Runs") +
  theme_minimal()

# Create the scatter plot for Division W (red dots)
plot_w <- ggplot(division_w, aes(x = Walks, y = Runs)) +
  geom_point(color = "red") +  # Red dots
  labs(title = "Division W", x = "Walks", y = "Runs") +
  theme_minimal()

# Create the label for the subtitle, placed at the bottom-left corner with size 10 text
subtitle <- textGrob("Figure 1.3", gp = gpar(fontsize = 10, fontface = "plain"), just = c("left", "bottom"))

# Arrange the two plots side by side and add the subtitle
grid.arrange(plot_e, plot_w, ncol = 2)
grid::grid.text("Figure 1.3", x = unit(0, "npc"), y = unit(0, "npc"), just = c("left", "bottom"), gp = gpar(fontsize = 10))

```
```{r}
# Create a new column "Division" for plotting purposes
Hitters$Division <- ifelse(Hitters$Division == "E", "Division E", "Division W")

# Create the scatterplot and separate by Division
scatterplot <- ggplot(Hitters, aes(x = Walks, y = Runs, color = Division)) +
  geom_point(size = 1) +  # Points with specified size, color mapped to Division
  scale_color_manual(values = c("Division E" = "blue", "Division W" = "red")) +  # Blue for Division E, Red for Division W
  labs(
    x = "Walks",
    y = "Runs"
  ) +
  facet_wrap(~ Division, scales = "free_x", ncol = 2) +  # Separate plots by Division (side by side)
  theme_minimal() +
  theme(
    plot.margin = margin(t = 20, r = 20, b = 50, l = 20),  # Adjust bottom margin to create space for the label
    plot.subtitle = element_text(hjust = 0, vjust = 1, size = 10, face = "plain"),  # Subtitle settings
    plot.caption = element_text(hjust = 0, vjust = 0, size = 10, face = "plain"),  # Caption settings
    legend.position = "none"  # Remove the legend
    ) +
  labs(caption = "Figure 1.4")  # Add label "Figure 1.4" at the bottom-left corner

# Show the plot
print(scatterplot)
```
### Solution Q2.2
```{r}

# Calculate the correlation between Walks and Runs by Division and round the correlation to 3 decimal places
correlation_by_division <- Hitters %>%
  group_by(Division) %>%
  summarize(Correlation = round(cor(Walks, Runs, method = "pearson"), 3)) %>%
  as_tibble()  # Convert to tibble for better display

# Print the result
print(correlation_by_division)

```
### Solution Q2.3
```{r}
# Convert 'Division' to a factor (if it's not already)
Hitters$Division <- as.factor(Hitters$Division)

# Fit the linear regression model
model <- lm(Runs ~ Walks + Division, data = Hitters)

# Print the summary of the model
summary(model)
```
### Solution Q2.4
```{r}
# Fit the linear regression model
model <- lm(Runs ~ Walks + Division, data = Hitters_clean)

# Store the parameter estimates (coefficients) in the 'fit.coef' object
fit.coef <- coef(model)

# Print the 'fit.coef' object
print(fit.coef)
```
### Solution Q2.5
```{r}
# Extract standardized residuals
std_residuals <- rstandard(model)

# Create a data frame for ggplot
qq_data <- data.frame(residuals = std_residuals)

# Create the QQ plot using ggplot2
ggplot(qq_data, aes(sample = residuals)) +
  geom_qq() +  # Create the QQ plot
  geom_qq_line(col = "red") +  # Add the normal reference line
  labs(
    x = "x",  # X-axis label
    y = "y"   # Y-axis label
  ) +
  theme_minimal() +  # Apply minimal theme
  theme(
    plot.margin = margin(t = 20, r = 20, b = 50, l = 10),  # Adjust bottom margin for space
    plot.subtitle = element_text(hjust = 0, vjust = 1, size = 10, face = "plain"),  # Left-align the subtitle
    plot.caption = element_text(hjust = 0, vjust = 0, size = 10, face = "plain")  # Add custom caption as bottom-left label
  ) +
  labs(caption = "Figure 1.5")  # Add subtitle outside the chart

```

  
## Question 3

Create a new dataset in which only observations with number of runs in 1986 greater than 30 are included. The following variables should be included in the dataset: <tt>Hits</tt>, <tt>HmRun</tt>, <tt>Runs</tt>, <tt>Walks</tt> and <tt>Division</tt>. 
  
  1. How many observations are included in the new dataset.

  2. Sort the new data according to the variable the number of hits in 1986 (the variable <tt>Hits</tt>). Print the top 5 observations in each division.
  
  3. Export the new dataset that was created in Q3.1 as an excel file (and include the data in out output that you submit as a solution for the exam).
  
### Solution Q3.1
```{r}
new_data <- Hitters %>%
  filter(Runs > 30) %>%
  dplyr::select(Hits, HmRun, Runs, Walks, Division)
num_observations <- nrow(new_data)
cat("Number of observations in the new dataset: ", num_observations, "\n")
```
### Solution Q3.2
```{r}
sorted_data <- new_data %>%
  arrange(Division, desc(Hits))  # Sort by Division and Hits (descending order)

# Print the top 5 observations from each Division
top_5_by_division <- sorted_data %>%
  group_by(Division) %>%
  slice_head(n = 5)  # Get top 5 from each division

print("Top 5 observations in each Division:\n")
print(top_5_by_division)
```
### Solution Q3.3
```{r}
library(writexl)  # To export as an Excel file
write_xlsx(new_data, path = "Hitters_filtered_data.xlsx")
cat("The new dataset has been exported as 'Hitters_filtered_data.xlsx'.\n")
```

# Part 2 : the <tt>Hitters</tt> data  
  

## Question 4  
  
In this part you need to prepare a presentation of 5 slides **using R markdown** about the analysis that you conducted in part 1. 

1. Your presentation should include a title page, at least one slide with text, at least one slide with a Graphical display and at least one slide in which you print an output from a statistical model or a statistical test applied to the data.
2. Create from the presentation a PDF file and add this file with the Rmd file that was used to produce the presentation to your solution's output.


# Part 3: the <tt>Boston</tt> data

In this part of the exam, we focus on the <tt>Boston</tt> dataset which is a part of the <tt>MASS</tt> R package. To access the data you need to install the package. More information can be found in https://www.statology.org/boston-dataset-r/. Use the code below to access the data. 

```{r, warning=FALSE, message=FALSE}
library(MASS)
data(Boston)
names(Boston)
```

## Question 5

1. How many observations and variables are included in the dataset? How many missing values, per each variable, are there in the dataset?

2. Calculate the minimum and maximum for the variables <tt>crim</tt>, <tt>zn</tt> and <tt>indus</tt> across the levels of the variable <tt>chas</tt>. Produce the panel below.

3. Count the number of homes that are near the Charles River (i.e., observations with <tt>chas</tt> equal to 1) vs. those that are not located near to the Charles river (observations with <tt>chas</tt> equal to zero).

4. For each level of the variable <tt>chas</tt>, calculate the average number of rooms per dwelling (the variable <tt>rm</tt>). Sort the data according to the average number of rooms per dwelling. 

### Solution Q5.1

```{r}
# 1. How many observations and variables are included in the dataset?
num_observations <- nrow(Boston)
num_variables <- ncol(Boston)

# Check for missing values in each variable
missing_values <- colSums(is.na(Boston))

# Print the results
cat("Number of observations:", num_observations, "\n")
cat("Number of variables:", num_variables, "\n")
cat("Missing values per variable:\n")
print(missing_values)
```
### Solution Q5.2
```{r}
# Calculate min and max for crim, zn, and indus across the levels of chas
summary_tibble <- Boston %>%
  group_by(chas) %>%
  summarize(
    crim_min = min(crim, na.rm = TRUE),
    crim_max = max(crim, na.rm = TRUE),
    zn_min = min(zn, na.rm = TRUE),
    zn_max = max(zn, na.rm = TRUE),
    indus_min = min(indus, na.rm = TRUE),
    indus_max = max(indus, na.rm = TRUE)
  ) %>%
  as_tibble()

# Print the tibble
print(summary_tibble)
```
### Solution Q5.3
```{r}
# Count the number of homes near the Charles River (chas = 1) vs. not near (chas = 0)
chas_counts <- Boston %>%
  group_by(chas) %>%
  summarize(homes_count = n()) %>%
  as_tibble()

# Print the counts
print(chas_counts)
```
### Solution Q5.4
```{r}
# Calculate the average number of rooms per dwelling (rm) for each level of chas
average_rm <- Boston %>%
  group_by(chas) %>%
  summarize(avg_rooms = mean(rm, na.rm = TRUE)) %>%
  arrange(avg_rooms) %>%
  as_tibble()

# Print the average number of rooms per dwelling
print(average_rm)
```

## Question 6

1. Create a new data frame, <tt>Boston2</tt>, for which the crime rate (the variable <tt>crim</tt>) is lower than 5 and the proportion of lower-status population (the variable <tt>lstat</tt>) is lower than 10. How many observations are included in this data frame?

2. What are the average median home value (the variable <tt>medv</tt> ) and the average number of rooms per dwelling (the variable <tt>rm</tt>) for the dataset created in Q6.1.

3. Visualize the relationship between <tt>medv</tt> and <tt>rm</tt> for the dataset created in Q6.1 as shown in Figure 6.1.

4. Identify the outlying observations for which the average number of rooms per dwelling (the variable <tt>rm</tt>) is smaller than 5 or higher than 8.75 in the dataset created in Q6.1. Add the value of the average number of rooms per dwelling to the figure (inside the frame) as shown in Figure 6.2.

5. Exclude the three outliers that was marked in Figure 6.2 from the data and produce Figure 6.3, label points with extreme values of <tt>medv</tt> i.e, observation for which the value of the variable <tt>medv</tt> is above the 90th percentile.

### Solution Q6.1
```{r}
# Create a new data frame for crim < 5 and lstat < 10
Boston2 <- Boston %>%
  filter(crim < 5, lstat < 10)

# Count the number of observations
n_obs <- nrow(Boston2)
cat("Number of observations in Boston2:", n_obs, "\n")
```
### Solution Q6.2
```{r}
# Calculate average medv and rm for the dataset created in Q6.1
avg_values <- Boston2 %>%
  summarize(
    avg_medv = mean(medv, na.rm = TRUE),
    avg_rm = mean(rm, na.rm = TRUE)
  )
print(avg_values)
```
### Solution Q6.3
```{r}
# Visualize the relationship between medv and rm for Boston2 (Figure 6.1)
ggplot(Boston2, aes(x = rm, y = medv)) +
  geom_point(size = 1, alpha = 0.8) +
  geom_smooth(method = "lm", color = "blue", linetype = "solid", se=FALSE)  +  # Strong solid blue diagonal line
  labs(
    x = "rm",
    y = "medv",
    caption = "Figure 6.1"
  ) +
  theme_minimal() +
  theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0))
```
### Solution Q6.4
```{r}
# Identify and visualize outliers based on rm < 5 or rm > 8.75 (Figure 6.2)
Boston2 <- Boston2 %>%
  mutate(outlier = ifelse(rm < 5 | rm > 8.75, "Outlier", "Normal"))

# Add the value of rm to the figure for outliers
ggplot(Boston2, aes(x = rm, y = medv, color = outlier)) +
  geom_point(size = 1, alpha = 0.8) +
  geom_smooth(method = "lm", color = "blue", linetype = "solid", se=FALSE)  +  # Strong solid blue diagonal line
  geom_text(data = subset(Boston2, outlier == "Outlier"), aes(label = round(rm, 2)),
            hjust = -0.2, vjust = 0.5, size = 3) +
  labs(
     x = "rm",
    y = "medv",
    caption = "Figure 6.2"
  ) +
  scale_color_manual(values = c("Outlier" = "red", "Normal" = "black")) +
  theme_minimal()+
  theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0))

```
### Solution Q6.5
```{r}
# Exclude the outliers and create Figure 6.3
Boston3 <- Boston2 %>%
  filter(rm >= 5 & rm <= 8.75)

# Identify extreme values of medv (above the 90th percentile)
medv_90th <- quantile(Boston3$medv, 0.9, na.rm = TRUE)
Boston3 <- Boston3 %>%
  mutate(extreme_medv = ifelse(medv > medv_90th, "Extreme", "Normal"))

# Visualize the relationship, label extreme medv points
ggplot(Boston3, aes(x = rm, y = medv, color = extreme_medv)) +
  geom_point(size = 1, alpha = 0.8) +
    geom_smooth(method = "lm", color = "blue", linetype = "solid", se=FALSE)  +  # Strong solid blue diagonal line
  geom_text(data = subset(Boston3, extreme_medv == "Extreme"), aes(label = round(medv, 2)),
            hjust = -0.2, vjust = 0.5, size = 3) +
  labs(
        x = "rm",
    y = "medv",
    caption = "Figure 6.3"
  ) +
  scale_color_manual(values = c("Extreme" = "red", "Normal" = "black")) +
  theme_minimal()+ theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0))
```

## Question 7

1. Define a new categorical variable <tt>crim_cat</tt> in the following way: Re-code the variable <tt>crim</tt> into three categories:

    crim <5: Low.\
    crim 5-15: Medium.\
    crim >15: High.
    
Count how many observations are included in each category.

2. Produce the pie plot and the barplot in a figure with one row of two columns, as presented in Figure 7.1.

3. Produce the frequency table below and Figure 7.2 (the figure shows the proportion of each category of the variable <tt>crim_cat</tt> across the levels of the variable <tt>chas</tt>).

4. Use a chi-square test to test the hypothesis whether or not a home is near the Charles River (the variable <tt>chas</tt>) and the categorical crime variable  <tt>crim_cat</tt> are independent.

### Solution Q7.1
```{r}
#Define crim_cat and count observations in each category
Boston$crim_cat <- cut(Boston$crim,
                       breaks = c(-Inf, 5, 15, Inf),
                       labels = c("Low", "Medium", "High"),
                       right = FALSE)
# Count observations in each category
crim_cat_counts <- table(Boston$crim_cat)
print(crim_cat_counts)
```
### Solution Q7.2
```{r}
# Produce pie plot and barplot in a single figure
par(mfrow = c(1, 2), oma = c(0, 0, 0, 4), mar = c(2, 2, 2, 5))  # Adjust outer margins and individual plot margins

# Pie plot
pie(crim_cat_counts, col = c("red", "green", "blue"),
    labels = crim_cat_counts, clockwise = TRUE)
legend("right", legend = names(crim_cat_counts),
       fill = c("red", "green", "blue"), title = "Category", bty = "n", xpd = TRUE, inset = c(-0.5, 0))

# Barplot
bar_heights <- barplot(crim_cat_counts, col = c("red", "green", "blue"))
text(x = bar_heights, y = crim_cat_counts+30, labels = crim_cat_counts, xpd = TRUE, col = "black")
legend("right", legend = names(crim_cat_counts),
       fill = c("red", "green", "blue"), title = "Category", bty = "n")
```
### Solution Q7.3
```{r}
#Frequency table and proportion plot by chas
chas_crim_table <- table(Boston$chas, Boston$crim_cat)
print(chas_crim_table)

# Proportion table
# chas_crim_prop <- prop.table(chas_crim_table, margin = 1)
# print(chas_crim_prop)

# Proportion plot using ggplot2
library(ggplot2)
chas_crim_df <- as.data.frame(chas_crim_prop)
colnames(chas_crim_df) <- c("chas", "crim_cat", "proportion")
chas_crim_df$chas <- as.factor(chas_crim_df$chas)

# Plot
ggplot(chas_crim_df, aes(x = crim_cat, y = proportion, fill = chas)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Proportion of crim_cat across levels of chas",
       x = "Crime Category (crim_cat)", y = "Proportion", fill = "chas", caption = "Figure 7.2")+ theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0))+
  theme_minimal()
```
### Solution Q7.4
```{r}
chisq_test <- chisq.test(chas_crim_table)
print(chisq_test)
```

## Question 8

1. Calculate the correlation between the proportion of Black residents by town (the variable <tt>black</tt>) and the status of the population (the variable <tt>lstat</tt>) using the R function <tt>cor.test()</tt>.

2. Use the R package <tt>corrplot</tt> to produce the heatmap of correlations between variables shown in Figure 8.1. Note that the categorical variables are excluded form the data in this Figure.

### Solution Q8.1
```{r}
# Calculate the correlation between the proportion of Black residents by town (black) and the status of the population (lstat)
correlation_result <- cor.test(Boston$black, Boston$lstat)
print(correlation_result)
```
### Solution Q8.2
```{r}
# Load the corrplot package
library(corrplot)

# Select only numeric variables (excluding categorical variables like "chas")
numeric_data <- Boston[, sapply(Boston, is.numeric)]
numeric_data <- numeric_data[, !names(numeric_data) %in% "chas"]

# Calculate the correlation matrix
correlation_matrix <- cor(numeric_data)

# Create the correlation heatmap using corrplot
corrplot(correlation_matrix, method = "color", type = "upper", 
         order = "original", tl.col = "red", tl.srt = 45)

# Add caption "Figure 8.1" at the bottom left corner
mtext("Figure 8.1", side = 1, line = 3, at = -0.3, cex = 0.8, adj = 0)
```
## Question 9

1. Define a new categorical variable, <tt>medv_cat</tt>, in the following way: Re-code the variable <tt>medv</tt> into three categories:

    medv < 15: Low.\
    medv 15-25: Medium.\
    medv > 25: High.
    
Include the new variable in the <tt>Boston</tt> dataset and produce the the table below.


2. Produce Figure 9.1.


3. Test if the means of the variable <tt>nox</tt> across the three groups of the variable <tt>medv_cat</tt> are equal using the Kruskal-Wallis test.

4. Produce Figure 9.2. To make the plot, you can use the function <tt>ggline()</tt> of the package <tt>ggpubr</tt> or any other R package/function that you wish. Do not forget to add the error bars to the figure.


### Solution Q9.1
```{r}
# Define the new categorical variable 'medv_cat'
Boston$medv_cat <- cut(Boston$medv,
                       breaks = c(-Inf, 15, 25, Inf),
                       labels = c("Low", "Medium", "High"))

# Create the table for the new categorical variable
medv_cat_table <- table(Boston$medv_cat)
print(medv_cat_table)
```
### Solution Q9.2
```{r}
# Create a violin plot with a box plot inside and custom colors
ggplot(Boston, aes(x = medv_cat, y = nox, fill = medv_cat)) +
  geom_violin(trim = TRUE,alpha = 0.5) +
  geom_boxplot(width = 0.1, aes(fill = medv_cat), color = "black", outlier.colour = "black",alpha =0.5) +  # Boxplot fill mapped to medv_cat
  scale_fill_manual(values = c("Low" = "red", "Medium" = "green", "High" = "blue")) +  # Custom colors for medv_cat
  labs(x = "medv_cat", y = "nox", caption = "Figure 9.1")+ theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0))+ 
  guides(fill = guide_legend(title = "medv_cat", title.position = "top", 
                             label.position = "right", override.aes = list(size = 5)))+
  theme_minimal()
```
### Solution Q9.3
```{r}
# Perform Kruskal-Wallis test
kruskal_test_result <- kruskal.test(nox ~ medv_cat, data = Boston)
print(kruskal_test_result)
```
### Solution Q9.4
```{r}
# Load necessary library for ggline
library(ggpubr)

# Create the plot with scatterplot, mean points, and error bars
ggplot(Boston, aes(x = medv_cat, y = nox, color = medv_cat)) +
  # Scatterplot layer with jitter for better visualization
  geom_point(position = position_jitter(width = 0.2), size = 1, alpha = .5) +
  # Error bars for mean with standard error
  stat_summary(fun.data = mean_se, geom = "errorbar", width = .3, color = "black") +
  # Mean points
  stat_summary(fun = mean, geom = "point", size = 1, color = "black") +
  # Custom color palette for medv_cat categories
  scale_color_manual(values = c("High" = "blue", "Medium" = "green", "Low" = "red")) +
  # Add axis labels and title
  labs(
    x = "medv_cat",
    y = "mean_nox",
  caption = "Figure 9.2")+ theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0))+
  # Minimal theme for a clean look
  theme_minimal()
  
```

## Question 10

For this question, use the version of the <tt>Boston</tt> dataset produced in Q9.1. 

1. Categorize the <tt>crim</tt> and <tt>nox</tt> variables into three levels ("Low," "Medium," and "High") and two levels ("Low","High"), respectively,  based on their quantiles as below:

  <tt>crim_level</tt>: Represents the crime rate divided into three groups:

      "Low": Bottom 33% of crime rate values.
      "Medium": Middle 33% of crime rate values.
      "High": Top 33% of crime rate values.

  <tt>nox_level</tt>: Represents nitric oxide concentration divided into two groups:

      "Low": Bottom 50% of nitric oxide concentration values.
      "High": Top 50% of nitric oxide concentration values.

2. Produce the plot in Figure 10.1 which shows separate density plots of <tt>medv</tt> for each category of <tt>nox_level</tt> (Low,High), with each density plot color-coded by <tt>crim_level</tt>.

3. For subjects with Low level of crim, conduct a t-test to test the hypothesis that the mean <tt>medv</tt> is equal between the low and high nitrogen oxides concentration groups.

4. Create a R object that contain the $95\%$ confidence interval for the mean difference. **DO NOT** use <tt>object=c(3.932519,8.891779)</tt>. 


### Solution Q10.1
```{r}
# Categorizing crim into three levels (Low, Medium, High)
Boston <- Boston %>%
  mutate(crim_level = case_when(
    crim <= quantile(crim, 1/3) ~ "Low",
    crim > quantile(crim, 1/3) & crim <= quantile(crim, 2/3) ~ "Medium",
    TRUE ~ "High"
  ))

# Categorizing nox into two levels (Low, High)
Boston <- Boston %>%
  mutate(nox_level = ifelse(nox <= median(nox), "Low", "High"))

```
### Solution Q10.2
```{r}
# Produce density plot for medv by nox_level and color-coded by crim_level

ggplot(Boston, aes(x = medv, fill = crim_level)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~ nox_level, ncol = 1) +
  scale_fill_manual(values = c("Low" = "red", "Medium" = "green", "High" = "blue")) +
  labs(
    x = "medv",
    y = "density",
    fill = "crim_level",
  caption = "Figure 10.1")+ theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0))+
  # Minimal theme for a clean look
  theme_minimal()
```
### Solution Q10.3
```{r}
# Perform t-test for Low crime level group
low_crim_data <- subset(Boston, crim_level == "Low")

# t-test for mean difference between Low and High nox_level
t_test_result <- t.test(medv ~ nox_level, data = low_crim_data)
t_test_result
```
### Solution Q10.4
```{r}
# Extract and print the 95% confidence interval for the mean difference
conf_interval <- t_test_result$conf.int
print(conf_interval)
```


# Part 4: the <tt>PimaIndiansDiabetes2</tt> data

In this part of the exam, the questions are focused on the <tt>PimaIndiansDiabetes2</tt> dataset which is a part of the <tt>mlbench</tt> R package. To access the data you need to install the package. More information about the dataset and variables can be found in https://search.r-project.org/CRAN/refmans/mlbench/html/PimaIndiansDiabetes.html. Use the code below to access the data. 

```{r, warning=FALSE, message=FALSE}
library(mlbench)
data(PimaIndiansDiabetes2)
names(PimaIndiansDiabetes2)
```


## Question 11.

1. Filter out observations with missing values and define a new dataset: <tt>new_PimaIndiansDiabetes2</tt>.
How many observations are included in the new dataset?

2. For each level of diabetes status (the variable <tt>diabetes</tt>), identify the top 5 patients with highest <tt>glucose</tt> and lowest <tt>mass</tt> values and produce the object bellow.


### Solution Q11.1
```{r}
# Filter out observations with missing values and define a new dataset new_PimaIndiansDiabetes2
new_PimaIndiansDiabetes2 <- na.omit(PimaIndiansDiabetes2)

# Count the number of observations in the new dataset
num_observations <- nrow(new_PimaIndiansDiabetes2)
cat("Number of observations in the new dataset:", num_observations, "\n")
```
### Solution Q11.2
```{r}
# Get top 5 highest glucose and top 5 lowest mass values for each diabetes group
top_patients_glucose_mass <- new_PimaIndiansDiabetes2 %>%
  group_by(diabetes) %>%
  # Get top 5 highest glucose values
  arrange(diabetes, desc(glucose)) %>%
  slice_head(n = 5) #%>%
  # Get top 5 lowest mass values
  #bind_rows(
  #  new_PimaIndiansDiabetes2 %>%
  #    group_by(diabetes) %>%
  #    arrange(diabetes, mass) %>%
  #    slice_head(n = 5)
  #) %>%
  #ungroup()

# View the result
top_patients_glucose_mass
```

## Question 12.

In this question we use the <tt>PimaIndiansDiabetes2</tt> dataset.

1. Remove missing values from the variables <tt>glucose</tt> and <tt>mass</tt> and create a new dataset <tt>new_PimaIndiansDiabetes3</tt>. How many observationas are included in the new dataset ?

2. Create a new variable <tt>glucose_level</tt> which categorizes the variable <tt>glucose</tt> as "Low", "Normal", or "High" based on quantiles (i.e., bottom 25% as Low, 25%-75% as Normal, and top 25% as High).

3. Define a new R objectes, the mean (<tt>mean_mass</tt>) and standard deviation (<tt>sd_mass</tt>) of the variable <tt>mass</tt> within each <tt>glucose_level</tt> category and produce the folowing table:

### Solution Q12.1
```{r}
# Remove missing values from the variables glucose and mass and create a new dataset new_PimaIndiansDiabetes3
new_PimaIndiansDiabetes3 <- PimaIndiansDiabetes2 %>%
  filter(!is.na(glucose) & !is.na(mass))

# Check how many observations are included in the new dataset
cat("Number of observations in the new dataset:",nrow(new_PimaIndiansDiabetes3))
```
### Solution Q12.2
```{r}
# Create a new variable glucose_level which categorizes the variable glucose as "Low", "Normal", or "High"
new_PimaIndiansDiabetes3 <- new_PimaIndiansDiabetes3 %>%
  mutate(glucose_level = case_when(
    glucose <= quantile(glucose, 0.25) ~ "Low",
    glucose > quantile(glucose, 0.25) & glucose <= quantile(glucose, 0.75) ~ "Normal",
    glucose > quantile(glucose, 0.75) ~ "High"
  ))
```
### Solution Q12.3
```{r}
# Define the mean (mean_mass) and standard deviation (sd_mass) of the variable mass within each glucose_level category
summary_table <- new_PimaIndiansDiabetes3 %>%
  group_by(glucose_level) %>%
  summarise(
    mean_mass = mean(mass, na.rm = TRUE),
    sd_mass = sd(mass, na.rm = TRUE)
  ) %>%
  # Round the values to the nearest tenth
  mutate(
    mean_mass = round(mean_mass, 1),
    sd_mass = round(sd_mass, 1)
  )

# View the summary table
summary_table
```

## Question 13.

In this question we use the dataset <tt>new_PimaIndiansDiabetes3</tt> that was created in Q12.1. 

1. Figure 13.1 shows multi boxplot displaying the distribution of the variable <tt>mass</tt> by age groups (<tt>age_group</tt>), separated by <tt>diabetes</tt> status.
Note that the data points in Figure 13.1 are colored according to the  <tt>glucose_level</tt>. Produce Figure 13.1.


### Solution Q13.1
```{r}
# Create glucose_level as in the previous task
new_PimaIndiansDiabetes3 <- new_PimaIndiansDiabetes3 %>%
  mutate(glucose_level = case_when(
    glucose <= quantile(glucose, 0.25) ~ "Low",
    glucose > quantile(glucose, 0.25) & glucose <= quantile(glucose, 0.75) ~ "Normal",
    glucose > quantile(glucose, 0.75) ~ "High"
  ))

# Create age_group variable
new_PimaIndiansDiabetes3 <- new_PimaIndiansDiabetes3 %>%
  mutate(age_group = case_when(
    age < 30 ~ "Under 30",
    age >= 30 & age < 40 ~ "30-39",
    age >= 40 & age < 50 ~ "40-49",
    age >= 50 ~ "50+"
  ))

# Generate the plot with boxplot for diabetes status and jittered points for glucose level
ggplot(new_PimaIndiansDiabetes3, aes(x = age_group, y = mass)) +
  # Boxplot for diabetes status with custom fill colors
  geom_boxplot(aes(fill = diabetes), alpha = 0.5, outliers = FALSE) +
  # Scatterplot layer with jitter for glucose_level visualization
  geom_point(aes(color = glucose_level), position = position_jitter(width = 0.2), size = 1, alpha = 0.5) +
  facet_wrap(~diabetes) +  # Facet by diabetes status
  labs(
    x = "age_roup",
    y = "mass",
    color = "Glucose Level",  # Update color legend title for glucose_level
    fill = "Diabetes Status",  # Label for boxplot fill
    caption = "Figure 13.1"
  ) + 
  theme(plot.caption.position = "plot", plot.caption = element_text(hjust = 0)) +
  # Minimal theme for a clean look
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  ) +
  # Custom fill colors for diabetes status
  scale_fill_manual(values = c("neg" = "yellow", "pos" = "purple"))
```

## Question 14.

In this queation we use dataset <tt>new_PimaIndiansDiabetes3</tt>  created in Question Q12.1.

1. Create a new variable, <tt>age_adjusted_risk</tt>, based the equation below.

$$
\mathrm{age\_adjusted\_risk} = \sqrt{\frac{0.5 \times \mathrm{glucose} + 0.3 \times \mathrm{mass} + 0.2 \times \mathrm{pressure}}{\mathrm{age}}}.
$$


2. Produce the Figure 14.1. Note that the information that is provided in the title is an output from a two sample t-test of the adjusted risk (defined in Q14.1) across the diabetes groups (the variable <tt>diabetes</tt>). 



### Solution Q14.1
```{r}
# Create age_adjusted_risk variable
new_PimaIndiansDiabetes3 <- new_PimaIndiansDiabetes3 %>%
  mutate(age_adjusted_risk = sqrt((0.5 * glucose + 0.3 * mass + 0.2 * pressure) / age))
```
### Solution Q14.2
```{r}
# Perform a two-sample t-test on age_adjusted_risk across diabetes groups
t_test_result <- t.test(age_adjusted_risk ~ diabetes, data = new_PimaIndiansDiabetes3)

# Extract the necessary values from the t-test result
mean_diff <- round(t_test_result$estimate[1] - t_test_result$estimate[2], 2)
ci_lower <- round(t_test_result$conf.int[1], 2)
ci_upper <- round(t_test_result$conf.int[2], 2)
p_value <- round(t_test_result$p.value, 4)

# 3. Generate the plot (Figure 14.1)
ggplot(new_PimaIndiansDiabetes3, aes(x = diabetes, y = age_adjusted_risk, fill = diabetes)) +
  # Boxplot for age_adjusted_risk by diabetes status
  geom_boxplot(alpha = 0.5, outlier.size = 2, outlier.colour = "black") +
  labs(
    title = paste(
      "Mean Difference: ", mean_diff, "\n",
      "95% CI: ", ci_lower, " to ", ci_upper,
      " P-Value: ", p_value
    ),
    x = "diabetes",
    y = "age_adjusted_risk",
    fill = "diabetes"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )+
  # Custom fill colors for diabetes status
  scale_fill_manual(values = c("neg" = "yellow", "pos" = "purple"))
```

## Question 15.

1. Create a function that receives as an input: (1) a data frame (<tt>data</tt>), (2) a names of a categorical variable (<tt>group_col</tt>) and (3) all numeric variables (<tt>numeric_cols</tt>). The function output should be a table with the mean, median, standard deviation, and IQR for all the numeric variables in the data frame across the level of the  categorical variable.

2. Apply the function that you wrote in Q15.1 to the data frame (<tt>PimaIndiansDiabetes2</tt>), use the variable (<tt>diabetes</tt>) as the categorical variable and all the numerical variables in the data set. Print the <tt>mean</tt> of two numeric variables only (<tt>glucose</tt>, <tt>insulin</tt>).

### Solution Q15.1
```{r}
# Function to compute descriptive statistics for numeric variables across levels of a categorical variable
compute_summary_stats <- function(data, group_col, numeric_cols) {
  data %>%
    group_by(.data[[group_col]]) %>%
    summarise(across(all_of(numeric_cols), 
                     list(
                       mean = ~ mean(.x, na.rm = TRUE),
                       median = ~ median(.x, na.rm = TRUE),
                       sd = ~ sd(.x, na.rm = TRUE),
                       IQR = ~ IQR(.x, na.rm = TRUE)
                     ),
                     .names = "{.col}_{.fn}")) %>%
    ungroup()
}
```
### Solution Q15.2
```{r}
#  Get the list of numeric columns
numeric_columns <- names(PimaIndiansDiabetes2)[sapply(PimaIndiansDiabetes2, is.numeric)]

# Apply the function to the dataset
summary_table <- compute_summary_stats(
  data = PimaIndiansDiabetes2,
  group_col = "diabetes",
  numeric_cols = numeric_columns
)

# Select and print the mean of glucose and insulin only
summary_table %>%
  dplyr::select(matches("diabetes|glucose_mean|insulin_mean")) %>%
  print()
```


## Question 16.

1. Create a new dataset, <tt>PimaIndiansDiabetes5</tt>, from the original dataset <tt>PimaIndiansDiabetes2</tt> and remove missing values.

2. Using the new dataset created in Question 16.1, create another dataset , <tt>median_insulin_data</tt>, by including only patients over 40 years old (the variable <tt>age</tt>) with blood pressure above 70 (the variable <tt>pressure</tt>), and select only  patients whose insulin levels (the variable <tt>insulin</tt> is above the median insulin level. How many observations are included in the new dataset.


3. Using the dataset created in Question Q16.2, create a new dataset <tt>selected_median_insulin</tt> which includes the variables <tt>age</tt>, <tt>pressure</tt>, <tt>insulin</tt>, <tt>pedigree</tt>, <tt>pregnant</tt>, <tt>diabetes</tt> variables. Display the last six observations of the dataset. 

### Solution Q16.1
```{r}
# Create the new dataset without missing values
PimaIndiansDiabetes5 <- PimaIndiansDiabetes2 %>%
  na.omit()

# Check the number of observations in the new dataset
num_observations <- nrow(PimaIndiansDiabetes5)
print(paste("Number of observations in PimaIndiansDiabetes5:", num_observations))
```
### Solution Q16.2
```{r}
# Calculate the median insulin level from PimaIndiansDiabetes5
median_insulin <- median(PimaIndiansDiabetes5$insulin, na.rm = TRUE)

# Create a new dataset with the specified conditions
median_insulin_data <- PimaIndiansDiabetes5 %>%
  filter(
    age > 40,               # Patients over 40 years old
    pressure > 70,          # Blood pressure above 70
    insulin > median_insulin # Insulin level above the median
  )

# Check the number of observations in the new dataset
num_observations_median_insulin <- nrow(median_insulin_data)
print(paste("Number of observations in median_insulin_data:", num_observations_median_insulin))
```
### Solution Q16.3
```{r}
# Create the final dataset with the selected variables
selected_median_insulin <- median_insulin_data %>%
  dplyr::select(age, pressure, insulin, pedigree, pregnant, diabetes)

# Display the last six observations of the dataset
print("Last six observations of selected_median_insulin:")
tail(selected_median_insulin)
```

## Question 17.

In this question we use the dataset created in Q16.1 (<tt>PimaIndiansDiabetes5</tt>).

1. Create a new dataset <tt>filtered_primadia5</tt> by including  patients with the variable <tt>mass</tt> above the median and the variable <tt>pedigree</tt> above the mean. How many observations are included in the new dataset?


2. Using the new dataset, produce an animated dynamic plot, shown in Figure 17.1 (Note the plot is colored by the variable <tt>age</tt>). You need to look at this plot in the HTML file of the exam. Produce an identical plot. Note that it should be produced in the HTML version of your solution, on the PDF file of the solution it will be a static file.

3. Export Figure 17.1 that was produced in Q17.2 as an external file. Name the file <tt>3D_Bubble_Plot.html</tt> and make sure to add this exported file to the solutions folder. Note that in the PDF solution of the exam, Figure 17.1 will not be dynamic. 

### Solution Q17.1
```{r}
# Calculate the median mass and mean pedigree
median_mass <- median(PimaIndiansDiabetes5$mass, na.rm = TRUE)
mean_pedigree <- mean(PimaIndiansDiabetes5$pedigree, na.rm = TRUE)

# Filter the dataset based on the conditions
filtered_primadia5 <- PimaIndiansDiabetes5 %>%
  filter(
    mass > median_mass,       # Mass above the median
    pedigree > mean_pedigree  # Pedigree above the mean
  )

# Check the number of observations in the filtered dataset
num_observations_filtered <- nrow(filtered_primadia5)
print(paste("Number of observations in filtered_primadia5:", num_observations_filtered))
```
### Solution Q17.2
```{r}
# Load necessary libraries for dynamic plotting
library(plotly)

# Create the animated dynamic plot
fig <- plot_ly(
  data = filtered_primadia5,
  x = ~mass,
  y = ~pressure,
  z = ~insulin,
  color = ~age,
  #colors = "Viridis",  # Use a color scale based on age
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 5)
) %>%
  layout(
    title = "3D Bubble Plot of Mass, Pressure, and Insulin",
    scene = list(
      xaxis = list(title = "Mass"),
      yaxis = list(title = "Pressure"),
      zaxis = list(title = "Insulin")
    )
  )

# Show the plot
fig
```
### Solution Q17.3
```{r}
# Export the plot as an external HTML file
htmlwidgets::saveWidget(fig, file = "3D_Bubble_Plot.html")

print("The animated 3D bubble plot has been saved as '3D_Bubble_Plot.html'.")
```

## Question 18.

Create a new dataset, <tt>prima_data</tt>, without missing data data using <tt>PimaIndiansDiabetes2</tt>.

1. How many observations are included in the new dataset?

2. Recode the variable <tt>pregnant</tt> in the following way:
<tt>0 = "0"</tt>, <tt>1 = "1"</tt>, <tt>2 = "2"</tt> and <tt>\>= 3 = "3+"</tt>). Name the new variable <tt>pregnant_grouped</tt>. Add the new variable to the dataset <tt>prima_data</tt>. Print the first 5 observations for whom the number of pregnancies is equal to 2. 

3. Use the <tt>prima_data</tt> created in Q18.1, create a new dataset <tt>mean_mass_data</tt> containing the mean of the variable (<tt>mass</tt>) for each combination of grouped pregnancy levels (<tt>pregnancy_grouped</tt>) and diabetes status (the variable <tt>diabetes</tt>). What is the dimension of the new dataset? Print the new dataset.
4. Produce Figure 18.1 (blood pressure VS. pregnancies).

5. Produce the table below that shows the mean and SD of age by number of pregnancies.

6. Produce Figure 18.2. Note that the black dots are the mean age at each pregnancy group.

7. Produce the interactive plot which is shown in Figure 18.3. You need to look at the HTML version of the exam to see Figure 18.3 in an interactive form.


### Solution Q18.1
```{r}
# Create prima_data without missing values
prima_data <- PimaIndiansDiabetes2 %>%
  na.omit()

# Number of observations in prima_data
num_observations <- nrow(prima_data)
print(paste("Number of observations in prima_data:", num_observations))
```
### Solution Q18.2
```{r}
# Recode pregnant variable
prima_data <- prima_data %>%
  mutate(
    pregnant_grouped = case_when(
      pregnant == 0 ~ "0",
      pregnant == 1 ~ "1",
      pregnant == 2 ~ "2",
      pregnant >= 3 ~ "3+"
    )
  )

# Print the first 5 observations for pregnant == 2
subset_pregnant_2 <- prima_data %>%
  filter(pregnant_grouped == "2") %>%
  head(5)

print(subset_pregnant_2)
```
### Solution Q18.3
```{r}
# Calculate mean mass for each combination of pregnant_grouped and diabetes
mean_mass_data <- prima_data %>%
  group_by(pregnant_grouped, diabetes) %>%
  summarise(mean_mass = mean(mass, na.rm = TRUE), .groups = "drop")

# Dimensions of the dataset
dim_mean_mass_data <- dim(mean_mass_data)
print(paste("Dimensions of mean_mass_data:", paste(dim_mean_mass_data, collapse = " x ")))

# Print the new dataset
print(mean_mass_data)
```
### Solution Q18.4
```{r}
# Plot blood pressure vs. pregnancies
ggplot(prima_data, aes(x = pregnant_grouped, y = pressure, color = diabetes)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(position = position_jitter(width = 0.2), alpha = 0.5) +
  labs(
    title = "Figure 18.1: Blood Pressure vs. Pregnancies",
    x = "Pregnancy Group",
    y = "Blood Pressure",
    color = "Diabetes Status"
  ) +
  theme_minimal()
```
### Solution Q18.5
```{r}
# Calculate mean and SD of age by pregnancy group
age_summary <- prima_data %>%
  group_by(pregnant_grouped) %>%
  summarise(
    mean_age = mean(age, na.rm = TRUE),
    sd_age = sd(age, na.rm = TRUE),
    .groups = "drop"
  )

# Print the summary table
print(age_summary)
```
### Solution Q18.6
```{r}
# Mean age at each pregnancy group (black dots)
ggplot(prima_data, aes(x = pregnant_grouped, y = age)) +
  geom_boxplot(alpha = 0.5, fill = "lightblue") +
  stat_summary(
    fun = mean,
    geom = "point",
    shape = 21,
    size = 3,
    fill = "black"
  ) +
  labs(
    title = "Figure 18.2: Age Distribution by Pregnancy Group",
    x = "Pregnancy Group",
    y = "Age"
  ) +
  theme_minimal()
```
### Solution Q18.7
```{r}
# Create an interactive plot
interactive_fig <- plot_ly(
  data = prima_data,
  x = ~pregnant_grouped,
  y = ~pressure,
  z = ~mass,
  color = ~diabetes,
  colors = c("red", "blue"),
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 5, opacity = 0.6)
) %>%
  layout(
    title = "Figure 18.3: 3D Interactive Plot of Pregnancies, Pressure, and Mass",
    scene = list(
      xaxis = list(title = "Pregnancy Group"),
      yaxis = list(title = "Blood Pressure"),
      zaxis = list(title = "Mass")
    )
  )

# Display the interactive plot
interactive_fig

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_fig, file = "Figure_18_3D_Plot.html")

print("The interactive 3D plot has been saved as 'Figure_18_3D_Plot.html'.")

```

## Question 19.

In this question we use the dataset <tt>PimaIndiansDiabetes5</tt> that was created in Q16.1.

1. Use a **for loop** in which you calculate, at each step of the loop, the correlation between glucose level (the variable <tt>glucose</tt> and blood pressure the variable <tt>pressure</tt>) for each level of number of pregnancies (the variable <tt>pregnant</tt>). This mean that in step 1 you calculate the correlation between <tt>glucose</tt> <tt>pressure</tt> for observation with <tt>pregnant</tt>=0 etc. Produce the data frame bellow.


2. In the above panel, correlations between the variables for observations with number of pregnancies higher than 13 is NA. Change the for loop on Q19.1 so the NA values will not be included in the panel.



### Solution Q19.1
```{r}
# Get unique levels of the pregnant variable
pregnancy_levels <- sort(unique(PimaIndiansDiabetes5$pregnant))

# Initialize an empty data frame to store results
correlation_results <- data.frame(
  pregnant = integer(),
  correlation = numeric(),
  stringsAsFactors = FALSE
)

# Calculate correlation using a for loop
for (level in pregnancy_levels) {
  # Filter data for the current pregnancy level
  temp_data <- PimaIndiansDiabetes5 %>%
    filter(pregnant == level)
  
  # Calculate the correlation if there are at least 2 observations
  if (nrow(temp_data) > 1) {
    corr_value <- cor(temp_data$glucose, temp_data$pressure, use = "complete.obs")
  } else {
    corr_value <- NA
  }
  
  # Append results to the data frame
  correlation_results <- rbind(
    correlation_results,
    data.frame(pregnant = level, correlation = corr_value)
  )
}

# Print the correlation results
print(correlation_results)
```
### Solution Q19.2
```{r}
# Initialize a new data frame for the updated results
correlation_results_no_na <- data.frame(
  pregnant = integer(),
  correlation = numeric(),
  stringsAsFactors = FALSE
)

# Calculate correlation excluding pregnancies > 13
for (level in pregnancy_levels) {
  # Filter data for the current pregnancy level
  temp_data <- PimaIndiansDiabetes5 %>%
    filter(pregnant == level & pregnant <= 13)
  
  # Calculate the correlation if there are at least 2 observations
  if (nrow(temp_data) > 1) {
    corr_value <- cor(temp_data$glucose, temp_data$pressure, use = "complete.obs")
  } else {
    corr_value <- NA
  }
  
  # Append results to the data frame
  correlation_results_no_na <- rbind(
    correlation_results_no_na,
    data.frame(pregnant = level, correlation = corr_value)
  )
}

# Print the updated correlation results
print(correlation_results_no_na)

```


## Question 20.

In this question we use the dataset <tt>prima_data</tt> created in Question 18.1.


1. Produce the interactive plot which is shown Figure 20.1. You need to look at the HTML version of the exam to see the figure in an interactive format.

### Solution Q20.1
```{r}
library(GGally)
# Create the pair plot using ggpairs
pair_plot <- ggpairs(
  data = prima_data,
  columns = c("glucose", "mass", "pressure", "age"),  # Select variables for the plot
  aes(color = diabetes, alpha = 0.6),  # Color by diabetes and add transparency
  diag = list(continuous = wrap("densityDiag", alpha = 0.4)),  # Density plots on the diagonal
  lower = list(continuous = wrap("smooth", method = "lm", se = TRUE)),  # Regression lines on lower panels
  upper = list(continuous = wrap("cor", size = 4, stars = TRUE))  # Correlation coefficients on upper panels
) +
  theme_minimal() +  # Apply a clean theme
  theme(legend.position = "top")  # Move legend to the top

# Convert the ggplot object to an interactive plotly object
interactive_plot <- ggplotly(pair_plot)

# Save the interactive plot as an external HTML file
htmlwidgets::saveWidget(interactive_plot, "3D_Bubble_Plot.html")

# Print the interactive plot in the RStudio Viewer
interactive_plot
```